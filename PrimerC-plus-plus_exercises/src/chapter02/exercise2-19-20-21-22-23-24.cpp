/* exercise 2-19、2-20、2-21、2-22、2-23、2-24
** 练习2.19: 说明指针和引用的主要区别和联系
** solution：相同点：都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
** 不同点：
** 1、指针是一个实体，而引用仅是个别名
** 2、引用只能在定义时被初始化一次，之后不可变；指针可变；从一而终，见异思迁
** 3、引用没有const，指针有const，const的指针不可变
** 4、引用不能为空，指针可以为空
** 5、sizeof 引用 得到的是所指向的变量(对象)的大小，sizeof 指针 得到的是指针本身的大小
** 6、指针和引用的自增(++)运算意义不一样
** 7、引用是类型安全的，而指针不是 (引用比指针多了类型检查）
**
** 练习2.20: 请叙述下面这段代码的作用
** int i = 42;
** int *p1 = &i;
** *p1 = *p1 * *p1;
** solution: 完成了 42 的平方运算，并将计算结果存放在 i 变量中
**
** 练习2.21: 请解释下述定义。在这些定义中有非法的吗?如果有，为什么?
**     int i = 0;
** (a) double *dp = &i;
** (b) int *ip = i;
** (c) int *p = &i;
** solution: 
** (a) 非法，int类型的地址不能初始化 double 类型的指针，类型不匹配
** (b) 非法，int类型的值不能初始化 int 类型的指针，类型不匹配
** (c) 合法，int类型的地址能够初始化int类型的指针
**
** 练习2.22: 假设p是一个int型指针，请说明下述代码的含义
** if (p)  //...
** if (*p) // ...
** solution:
** 如果指针p非空，则执行代码；如果指针p指向的对象的值非零，则执行代码
**
** 练习2.23: 给定指针p,你能知道它是否指向了一个合法的对象吗?
** 如果能，叙述判断的思路;如果不能，也请说明原因
** solution: 指针有4种:
** 1、指向一个有效对象 
** 2、指向的是指向对象所占空间的下一个空间地址
** 3、空指针
** 4、无效指针, 上述情况之外的其他值，指针一定要初始化
** 指针能够解引用，则对于编译器而言是合法的
**
** 练习2.24: 在下面这段代码中为什么 p 合法而 1p 非法?
** int i = 42;
** void *p = &i;
** long *1p = &i;
** solution: void 可以匹配任意类型；long类型指针不能用int类型地址进行初始化
**
*/

#include <iostream>

int main()
{
    // solution 2-20
    int i = 42, *ptr1 = &i;
    *ptr1 = *ptr1 * *ptr1;
    std::cout << *ptr1 << "\t" << ptr1 << "\t" << i << std::endl;

    // solution 2-22
    int j = 10;
    void *p = &j;
    // void 可以匹配转换为任意类型，但是这样不能 解引用 该指针
    // std::cout << *p << "\t" << p << "\t" << j << std::endl;
    std::cout << p << "\t" << j << std::endl;

    return 0;
}

/* 编译命令操作流程
** 0、打开终端 terminal，VSCode使用 Ctrl+shift+`; Ubuntu使用 Ctrl+Alt+T
** 1、进入当前源文件路径，cd src; cd chapter02
** 2、编译源代码文件，g++ --version; g++ -o exercise exercise2-19-20-21-22-23-24.cpp
** 3、运行生成的可执行程序，exercise; Ubuntu使用 ./exercise
** 4、删除生成的可执行程序，rm -rf exercise.exe; Ubuntu使用 rm -rf exercise
*/
