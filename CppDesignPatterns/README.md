# 设计模式 Design Patterns

> **Design patterns** are typical solutions to common problems in software design. Each pattern is like a blueprint that you can customize to solve a particular design problem in your code.

> In software engineering, a **design pattern** is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn't a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.

In software engineering, a **software design pattern** or **design pattern** is a general, reusable solution to a commonly occurring problem in many contexts in software design. A design pattern is not a rigid structure that can be transplanted directly into source code. Rather, it is a description or a template for solving a particular type of problem that can be deployed in many different situations. Design patterns can be viewed as formalized best practices that the programmer may use to solve common problems when designing a software application or system.

Object-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. Patterns that imply mutable state may be unsuited for functional programming languages. Some patterns can be rendered unnecessary in languages that have built-in support for solving the problem they are trying to solve, and object-oriented patterns are not necessarily suitable for non-object-oriented languages.

Design patterns may be viewed as a structured approach to computer programming intermediate between the levels of a programming paradigm and a concrete algorithm.

## **设计模式**
- 创建型模式
    - 简单工厂模式 Simple Factory
    - 工厂方法模式 Factory Method
    - 抽象工厂模式 Abstract Factory
    - 创建者模式 Builder
    - 原型模式 Prototype
    - 单例模式 Singleton
- 结构型模式
    - [外观模式 Facade](Facade.cpp)
    - [适配器模式 Adapter](Adapter.cpp)
    - [代理模式 Proxy](Proxy.cpp)
    - [组合模式 Composite](Composite.cpp)
    - [享元模式 Flyweight](Flyweight.cpp)
    - [装饰模式 Decorator](Decorator.cpp)
    - [桥模式 Bridge](Bridge.cpp)
- 行为型模式
    - 中介者模式 Mediator
    - [观察者模式 Observer](Observers.cpp)
    - [观察者模式 Observer](ObserversClockTimer.cpp)
    - [观察者模式 Observer](ObserversWeather.cpp)
    - 命令模式 Command
    - 迭代器模式 Iterator
    - 模板方法模式 Template Method
    - 策略模式 Strategy
    - 状态模式 State
    - 备忘录模式 Memento
    - 解释器模式 Interpreter
    - 职责链模式 Chain of Responsibility
    - 访问者模式 Visitor

### 单例模式 [Singleton](https://refactoringguru.cn/design-patterns/singleton)

> 单例模式是一种创建型设计模式,能够保证一个类只有一个实例,并提供一个访问该实例的全局节点.

```C++
class Logger
{
public:
    static Logger& GetInstance()
    {
        static Logger logger;
        return &logger;
    }

private:
    Logger();
    Logger(const Logger&) = delete;
    Logger(Logger&&) = delete;
}
```

### 工厂模式 [Factory](https://refactoringguru.cn/design-patterns/factory-method)

> 工厂方法模式是一种创建型设计模式,其在父类中提供一个创建对象的方法,允许子类决定实例化对象的类型.

### Strategy 策略模式

> 定义一系列策略(算法), 并进行封装,可以相互转换, 使得策略(算法)可独立于客户程序. 策略模式是一种行为型设计模式, 策略模式在软件开发场景中定义了一系列的算法, 并将每个算法单独封装在可替换的对象中, 使应用程序在运行时可以根据具体的上下文来动态地选择和切换算法, 同时保持原有的代码架构不被修改. 策略模式的设计使得算法的实现与调用被分离, 让算法可以独立于外部客户端进行开发和改动, 使用独立的类来封装特定的算法, 也避免了不同算法策略之间的互相影响. 策略模式能适应多种应用场景, 为了满足业务需求, 应用程序在运行时可以选择不同的算法策略来达到最优的实现效果. 策略模式将不同的算法实现封装成独立的类, 使得算法的修改不会影响到客户端代码, 提高了应用程序的灵活性和可维护性; 策略模式的架构可以避免使用大量的if-else条件语句来大量判断不同的策略分支, 优化了代码结构, 增加了代码的可扩展性.

#### 策略模式的结构
- 策略上下文(Context):
    - Context类是策略模式的调度核心,其内部包含了一个策略对象,并通过调用具体的策略对象来完成具体操作;
    - Context类对外提供了与客户端交互的API接口, 并隐藏了具体的算法细节, Context类相当于一个中间件, 将算法封装与客户端调用进行了分离;
- 抽象策略类(Strategy):
    - Strategy类定义了一个公共接口,该公共接口最终将被具体的算法模块进行实现和重写;
- 具体策略类(ConcreteStrategy):
    - ConcreteStrategy类实现了Strategy类定义的公共接口;
    - 每一个具体策略类都包含特定的算法实现细节, 并用来处理特定的应用场景;
- 组件之间的工作步骤如下:
    1. 客户端根据业务需要选择一个具体策略类, 并初始化一个对应的策略对象
    2. 客户端将创建好的策略对象传递给策略上下文
    3. 策略上下文调用策略对象的接口函数
    4. 当客户端需要更换算法策略时, 可以重新选择一个具体策略类, 并传递一个新的策略对象给策略上下文

![](images/StrategyUML.png)

#### 策略模式的应用场景
- 文件格式处理: 代码可以根据不同的文件格式选择不同的解析策略, 例如文本格式、XML、JSON等
- 交易系统开发: 系统根据交易类型、支付渠道等，选择不同的处理策略
- 可配置应用开发: 用户可以根据不同的业务场景来动态选择不同的配置模板
- 通用API开发: 当同一个API需要提供多个版本或业务逻辑时, 策略模式可以帮助隐藏具体细节

#### 策略模式的优缺点
- 策略模式的优点:
    - 对"开闭原则"提供完美支持
    - 基于上下文和算法类的封装, 方便管理和调度一系列算法策略
    - 避免了if-else条件语句的大量使用
    - 支持灵活的替换算法策略, 代码的可读性和扩展性很强
    - 算法被封装以后, 可以独立地被多个客户端和上下文复用
- 策略模式的缺点:
    - 使类和对象的数量变得更多, 增加了系统的复杂性
    - 如果策略被划分得过于细化, 会导致过度设计, 不易于代码理解
    - 代码涉及多个对象的创建和销毁, 性能开销增大, 大量使用会引起性能问题


### Observer 观察者模式

> 定义对象间的一种一对多(变化的)的依赖关系, 当一个Object状态发生变化时, 所有依赖于其的对象都能得到通知并更新

- 观察者模式是一种行为型设计模式, 又被称为"发布-订阅"模式, 它定义了对象之间的一对多的依赖关系, 当一个对象的状态发生变化时, 所有依赖于它的对象都会收到通知并自动更新
- 观察者模式的关注点是对象之间的通信以及被观察对象的状态

![](images/Observers.png)

**观察者模式在现实生活中的抽象实例**
- 报纸订阅: 报纸的内容发生变化时, 订阅了该报纸的读者们都会收到通知并阅读最新的内容
- 股票投资: 股票的价格发生波动时, 投资者们会根据最新价格修改相应的投资决策
- 天气预报: 当天气发生变化时, 订阅了该服务的用户们会收到通知
- 网络论坛: 当论坛中有新的帖子或回复出现时, 论坛的用户们会收到通知并可以参与讨论

#### 观察者模式的结构
- 被观察者(Subject): 
    - 被观察的对象,它的内部包含了观察者对象的集合, 并提供了添加、通知和删除观察者对象的统一接口
- 观察者(Observer):
    - 接收Subject通知的对象, 它订阅了Subject的状态, 并提供了更新操作的统一接口
- 具体的被观察者(ConcreteSubject):
    - 包含Subject类接口的具体实现, 维护了观察者的列表, 自身状态发生变化时通知所有的观察者
- 具体的观察者(ConcreteObserver):
    - 包含Observer类接口的具体实现, 提供了更新操作的具体实现细节, 一旦收到Subject的通知便进行更新操作

**组件之间的工作步骤如下**
- 被观察者维护一个观察者的列表, 并提供了管理和通知观察者的方法
- 观察者与被观察者绑定(attach), 并将自己添加到观察者列表中
- 当被观察者的状态发生变化时, 开始通知观察者, 通知的方式一般是遍历观察者列表, 遍历时会调用每个观察者的更新方法
- 观察者完成具体的更新操作

![](images/ObserversUML.png)

#### 观察者模式的应用场景
- 事件驱动编程: GUI界面开发时, 监听用户在界面的各种操作, 如按钮点击、窗口关闭等
- 监控服务开发: 当系统状态发生变化时(例如磁盘空间不足),工具会收到通知
- 消息队列开发: 基于"消费者-生产者"模式进行通信, 当消息队列中有新的消息时, 消费者会收到通知

**观察者模式的优缺点**
- 观察者模式的优点:
    - 符合"开闭原则"的要求
    - 支持广播的通信方式
    - 支持事件驱动编程
    - 可以动态添加观察者, 代码扩展性好
- 观察者模式的缺点:
    - 每次状态变化都要遍历所有观察者, 性能开销大
    - 每次状态变化都要通知所有的观察者, 通信时间变长
    - 观察者数量过多会使代码的可读性变差
    - 当有多个客户端操作观察者的删除时, 会带来数据安全问题


### Chain of Responsibility 职责链模式

> 多个对象(一条责任链)都有机会处理请求, 从而避免发送者和接受者之间的关系, 这这些对象连成一条链, 并沿着这条链进行传递请求, 直到有一个对象处理该请求为止. 职责链模式, 又被称为责任链模式,是一种行为型设计模式,它让多个对象依次处理收到的请求,直到处理完成为止; 职责链模式需要使用多个对象, 其中的每个对象要么处理请求, 要么将请求传递给下一个对象, 该模式因此可以实现发送方与接收方的松散耦合; 在职责链模式中, 一个对象可以被理解为处理器, 每个处理器都包含对下一个处理器的引用, 多个对象之间形成了一个链表的结构.

![](images/ChainofResponsibilityUML.png)

#### 职责链模式的结构
**职责链模式主要包含以下组件**:
- 抽象处理器(Handler):
    - 处理器的抽象类, 声明处理请求的抽象接口, 并持有对下一个处理器的引用
- 具体处理器(ConcreteHandler)：
    - 继承自抽象处理器,包含了对处理请求接口的具体实现,负责处理特定类型的请求或将请求传递给下一个处理器
- 客户端(Client):
    - 负责创建处理器的实例, 并将它们加入到职责链中
    - 然后向第一个处理器发送请求, 并等待职责链的返回结果

**组件之间的工作步骤如下**
- 客户端将请求传递给职责链中的第一个处理器
- 第一个处理器尝试处理请求; 如果处理成功,则结束处理过程并返回结果;如果无法处理,则将请求转发给下一个处理器;
- 下一个处理器重复步骤2, 直到找到能够处理请求的处理器, 或者职责链中没有更多的处理器;
- 客户端获得处理结果

#### 职责链模式的应用场景
- 命令处理器: 比如在游戏或GUI应用中, 用户可以发送各种操作命令, 如“播放音乐”、“关闭窗口”, 而具体执行过程由一系列处理器完成
- 日志记录器: 将不同严重等级的日志交给不同的处理器去打印
- Web服务开发: 在Web服务中, 对请求进行校验和过滤，如权限验证、数据校验等
- 权限控制: 在用户权限管理中, 可以根据角色的不同职责分配不同的权限验证步骤
- 消息路由: 在网络通信中, 将不同类型的消息分别发送给不同的处理程序

#### 职责链模式的优缺点
- 职责链模式的优点:
    - 和命令模式类似, 可以实现发送者和接收者的解耦
    - 灵活性强, 可以修改职责链中的结构和顺序
    - 有扩展性, 可以在最小改动的情况下添加新的处理器
    - 处理器可以在不同的职责链中重复使用
- 职责链模式的缺点:
    - 对请求的处理可能覆盖不全, 导致bug的产生
    - 请求的处理过程十分冗长
    - 请求的传递涉及多个对象, 性能开销大
    - 责任链需要被一直维护和管理


### Adapter适配器模式
- 适配器模式是一种结构型设计模式, 用于将已有接口转换为调用者所期望的另一种接口
- 适配器模式让特定的API接口可以适配多种场景; 例如,现有一个名为"Reader()"的API接口只能解析txt格式的文件，给这个Reader()接口增加适配器以后,它可以同时支持xml、json、csv等格式的文件.
- 适配器是一个特殊的类, 它可以扩展或者说转接一些特定API接口的功能, 使得API接口可以被应用到更多对象或数据类型上
- 适配器会将适配过程进行封装, 从而隐藏适配的过程, 只对外界提供被适配以后的API接口

**适配器模式的主要组件**:
- 目标接口(Target): 提供给外部程序的统一接口, 是外部调用者(client)期望使用的接口
- 源接口(Adoptee): 已经具备一定的功能, 但是与Target不兼容的接口; 它包含了client所需要的功能, 但是不能被client所使用
- 适配器(Adapter): 对源接口进行适配, 使得源接口可以像目标接口一样被公共调用; 适配器提供了Target的接口实现, 并通过继承或组合的方式调用了Adoptee的接口

![Adapter](./images/Adapter.png)

**适配器模式的优点**:
- 可以实现对现有组件代码的复用
- 使得不兼容的组件之间可以成功交互
- 降低了各种接口之间的用法差异
- 方便集成第三方库或者API

> 适配器模式与桥接模式(Bridge Pattern)的区别: 两者的用途不同, 桥接模式的用途是将接口与实现分开; 适配器模式的用途是修改现有接口, 从而解决兼容问题.

#### 适配器模式的应用场景
在开发场景中, 适配器模式的应用场景有:
- 兼容相同业务下的不同接口实现
- 兼容不同的通信方式, 比如使用适配器将UDP通信转为内部的共享内存通信
- 处理代码中不同类之间交互时的兼容问题

> 在嵌入式开发场景, 经常使用的Wrapper, 也是一种适配器模式; Wrapper是指将传感器等硬件或者操作系统的底层API封装成一种高级接口或者类, 从而提供给上层应用去调用; Wrapper可以隐藏底层的具体实现细节, 使上层应用程序可以更加方便地使用底层接口; 例如 当嵌入式设备需要读写摄像头数据时, 可以把摄像头提供的SDK封装成一个Wrapper, 从而简化了调用方式. 

**不推荐使用适配器的场景**:
- 原有接口的变动很大的时候
- 对接口性能要求很高的时候
- 适配器需要适配的地方过多的时候

**UML类图**
> Adapter类继承了Target类并重写了Target类的request接口, Adapter类实现request接口的时候调用了Adoptee类提供的specificRequest接口; 整体上 相当于Adapter类为Adoptee类的specificRequest接口做了适配.

![Adapter](./images/AdapterUML.png)

**适配器模式的分类**
- 类适配器
    - 类适配器以类继承的方式适配不兼容的源接口
    - C++语法支持继承自多个父类(钻石继承), 适配器同时继承了目标接口和源接口, 从而使得源接口的函数可以被目标接口所调用

![Adapter](./images/AdapterClass.png)

**对象适配器**
- 对象适配器以对象组合的方式适配不兼容的源接口; 所谓的对象组合, 是指在一个对象内部调用另一个对象的成员函数
- 对象适配器中包含了源接口的实例对象, 对象适配器的可扩展性更好, 方便加入新的功能进行适配

### Bridge 桥接模式
- 桥接模式是一种结构型设计模式, 用于将抽象与实现分离, 这里的"抽象"和"实现"都有可能是接口函数或者类
- 桥接模式让抽象与实现之间解耦合, 使得开发者可以更关注于实现部分, 调用者(Client)可以更关注于抽象部分
- 桥接模式可以将一个复杂的类进行拆分为好几个类, 开发者可以修改其中任意一个类的实现, 而不影响其他类的正常运行, 该模式可以降低代码的维护工作量, 降低代码风险
- 桥接模式的核心思想就是: 抽象化(Abstraction)与实现化(Implementation)
    - 抽象化: 忽略一些细节, 将具有共同特征的不同实体抽象为同一个对象
    - 实现化: 为抽象化提供具体的逻辑和代码实现

#### **桥接模式的结构**
桥接模式主要涉及的类:
- 抽象角色类: 是一个类,定义了统一的对外接口,并定义了接口的组成结构,但是不包含接口对应的具体实现
- 具体实现类: 是一个或多个类,该类包含了对抽象角色类的接口的具体代码实现; 这些类可以根据需求变化而独立变化,且不会影响到其他类的功能; 具体实现类与抽象角色类之间的关联方式采用的是组合而非继承
- 桥接类: 充当了抽象角色类和具体实现类之间的桥梁, 负责维护抽象角色类和具体实现类之间的关系, 它允许客户端在运行时选择使用哪个具体实现类

桥接模式的主要组件:
- Abstraction: 抽象类, 提供统一的抽象接口; 内部包含对Implementor类对象的引用
- RefinedAbstraction: 扩充抽象类, 有的教程里面称为"ExtendedAbstraction", Abstraction的子类, 扩充Abstraction的抽象接口
- Implementor: 实现类, 提供了实现类的接口, 这个接口的功能和以上的抽象接口不同
- ConcreteImplementor: 提供了实现类的接口对应的代码逻辑

![](./images/BridgeUML.png)

#### 桥接模式的应用场景
- 系统组件升级: 当需要为现有系统增加新功能或替换已有功能,但又不希望改变原有接口时
- 跨平台应用开发: 使用桥接模式来处理不同操作系统或硬件平台的差异,例如在移动端APP应用中,UI组件同时兼容ios和Android平台
- 第三方插件开发: 使用桥接模式开发出可支持多种第三方服务的组件,例如移动支付api
- API扩展: 当API的功能需要被扩展,又希望保持原有API的稳定时,使用桥接模式可以隐藏实现细节

**桥接模式的优缺点**
- 桥接模式的优点:
    - 分离接口的抽象与实现部分
    - 替代了继承的实现方式, 代码的可复用性更强
    - 桥接模式可以修改任意一个模块的功能实现而不影响整个系统
    - 可以向用户隐藏实现细节
    - 降低了类之间的依赖性
    - 代码的可维护性很强, 可以根据需求灵活地更换实现模块
- 桥接模式的缺点:
    - 引入了额外的抽象层, 使系统变得更复杂
    - 会额外增加系统的理解与设计难度
    - 接口调用增多, 带来额外的性能开销

### Proxy 代理模式
- 代理模式是一种结构型设计模式,该模式通过引入一个新的代理对象Proxy,来间接访问原始对象,从而使访问方式变得灵活和可控。
代理对象的设定减少了客户端与真实对象之间的直接交互
- 通过引入代理对象来间接访问原始的对象，达到延迟访问和隔离的效果，这就是代理模式的主要用途

#### 代理模式的结构
- 抽象对象(Subject): 定义了真实对象和代理对象的共同接口
- 真实对象(RealSubject): 又称为被代理对象，代理模式中的核心角色，定义了真正需要被代理的业务逻辑
- 代理对象(Proxy): 充当了客户端与真实对象之间的中介

![](./images/ProxyUML.png)

**代理模式的种类**
- 简单代理(Simple Proxy): 主要用于转发请求和处理一些基本操作，例如添加日志、计时等
- 远程代理(Remote Proxy): 当主体对象在另一个地址空间(如网络地址)时，远程代理会提供远程通信的功能，进行数据的访问和转换
- 智能引用代理(Smart Reference Proxy): 也称为共享代理，它维护了多个客户端对同一目标的共享引用，并提供统一的接口
- 虚拟代理(Virtual Proxy): 延迟针对昂贵资源的访问，只有在真正使用时才加载
- 保护代理(Protection Proxy): 主要用于访问权限的控制，比如身份验证、授权等

**代理模式的应用场景**
- 延迟加载: 使资源密集型的对象仅仅在被使用时才加载，例如，访问大型数据库、加载大批量图像数据等
- 访问控制: 代理可以通过添加身份验证来控制对真实主体的访问，可用于保护敏感数据
- 缓存机制: 代理可以缓存高频次的请求，从而减少系统开销，优化性能
- 日志记录和监控: 代理可用于记录或监控对真实主体执行的操作，而无需修改其代码
- 远程访问: 在分布式系统中，真实主体可能位于不同的计算机上，代理模式可以隐藏远程通信的复杂细节
- 状态管理: 代理可以同步管理多个客户端所共享的真实主体的状态，确保它们的一致性

**代理模式的优缺点**
- 代理模式的优点:
    - 可以在不修改被代理对象的情况下，增加额外的功能或控制访问方式
    - 可以在访问对象之前和之后进行一些处理，比如添加日志、添加时间戳等
    - 可以实现远程代理，使得客户端可以通过网络访问远程的对象
    - 可以防止未经授权访问真实主体
- 代理模式的缺点:
    - 引入新的类，增加代码复杂性
    - 读取资源时，需要通过代理来间接访问，造成额外的性能损失

### Decorator 装饰器模式
- 装饰器模式是一种结构型设计模式,它允许在不改变现有对象的情况下,动态地将功能添加到对象中
- 装饰器模式是通过创建具有新行为的对象来实现的,这些对象将原始对象进行了包装
- 装饰器模式遵循开放/关闭原则,允许开发者在不修改现有代码的情况下添加新的装饰器
- 日常开发中常用的装饰器属于类装饰器,通过继承父类来实现

#### 装饰器模式的结构
- 抽象组件(Component): 被装饰的对象, 声明了对外的统一接口
- 具体组件(ConcreteComponent): 包含抽象组件接口的具体代码实现
- 抽象装饰器(Decorator): 包含对抽象组件的指针或引用, 并定义了与抽象组件一致的接口
- 具体装饰器(ConcreteDecorator): 包含抽象装饰器接口的具体代码实现, 并且可以在调用对外接口之前或之后添加额外的行为

![](images/DecoratorUML.png)

#### 装饰器模式的应用场景
- 组件扩展: 在大型项目中,随着业务的增加,必定要添加新的功能,装饰器此时可以避免修改原有的基础组件
- API增强: 当提供API给第三方进行调用时,装饰器可以用于添加额外的功能,比如日志记录、安全校验等，而调用者无需知道具体的细节
- 权限管理: 装饰器可以用来控制对原有的特定接口的访问权限
- 缓存机制: 在网络请求或数据库查询等操作中,装饰器可以用来添加额外的缓存、重试、超时处理等功能

**装饰器模式的优缺点**
- 装饰器模式的优点:
    - 可以动态地添加或删除对象的功能, 无需修改原有的代码
    - 不影响现有对象的结构, 符合开闭原则
    - 可以灵活地扩展原有对象的功能
    - 可以使用多个装饰器对象来组合多种功能
    - 使得代码可以根据需要轻松地添加或移除功能
- 装饰器模式的缺点:
    - 使系统中增加额外的类变量
    - 装饰器对象与原始对象之间的关系过于复杂, 降低代码可读性

### Facade 外观模式
- 外观模式是一种结构型设计模式,又称为门面模式,也是一种基于创建对象来实现的模式,为子系统中的各组接口的使用提供了统一的访问入口
- 外观模式对外提供了一个对象,让外部客户端(Client)对子系统的访问都是基于该对象来完成,这个对象被称为外观对象(Facade Object),外观对象为子系统的访问提供了一个简单而且统一的入口
- 客户端只需要关注Facade提供的对外接口的用法, 而不需要关注子系统之间的复杂交互等细节

#### 外观模式的结构
- 外观对象(Facade): 它的底层封装了系统的各个子模块,向用户屏蔽了底层的复杂结构,在内部调用各种子系统的函数,对外提供一些简化的接口
- 子系统对象(SubSystem): 是组成复杂系统的各个独立模块,它们各自实现特定的功能,然后被Facade统一调用

![](images/FacadeUML.png)

#### 外观模式的应用场景
- 系统集成: 当多个组件或服务接口需要被统一管理和使用时,借助外观模式构建一个统一的入口
- API升级: 当API升级时,为了兼容旧版本的API接口的使用,创建一个外观模式的对象,既可以对外提供新的API接口,又向后兼容旧的API接口
- 开发第三方库或框架: 针对大型的库或者框架的开发,为了简化用户的使用,隐藏底层实现,对外提供一个简单且统一的接口
- 组件整合: 为了让项目中兼容不同架构和使用方式的组件时, 使用外观模式来规范化组件的调用方式

**外观模式的优缺点**
- 外观模式的优点:
    - 减少了需要客户端关注和处理的对象数,简化了接口的使用方式
    - 实现了子系统和客户端之间的解耦,使子系统的变更不会影响到客户端的调用方法
    - 降低了大型软件的编译难度,简化了大型软件在不同平台之间的移植过程
    - 对外提供接口的同时,可以针对单个子系统实现单独的优化和升级
    - 避免了客户端对内部底层逻辑的影响和破坏
    - 促进了子系统的模块化和可重用性
- 外观模式的缺点:
    - 对底层的过度包装会增加性能开销
    - 如果设计的不合理,会使重构变得有难度
    - 如果存在访问共享资源的情况,代码的编写不够严谨时,相同层次的子系统和子系统之间可能会互相影响
    - 子系统和子系统之间可能包含相同的功能,导致代码冗余

### Flyweight 享元模式
- 享元模式是一种结构型设计模式,它将每个对象中各自保存一份数据的方式改为多个对象共享同一份数据,该模式可以有效减少应用程序的内存占用
- 享元模式的核心思想是共享和复用, 通过设置共享资源来避免创建过多的实例
- 当应用程序的内部包含大量的对象, 且对象之间包含相似的数据或状态时, 可以使用享元模式来共享这些数据或状态
- 享元模式的内部涉及到工厂模式的使用, 因为它需要创建一个享元工厂来管理共享资源池; 这个共享资源池又称为享元池(Flyweight Pool), 里面包含多个访问共享数据的享元对象; 当客户端需要使用一个享元对象时, 享元工厂会从池中获取一个已有的享元对象, 如果对象不存在则创建一个新的享元对象

#### 享元模式的结构
- 内部状态(Intrinsic State): 对象之间容易重复的、可以共享的、且变动很少的成员变量,该变量在享元模式中被共享
- 外部状态(Extrinsic State): 对象之间各不相同的、不能共享的、且随着不同场景而变化的成员变量,该变量被调用的客户端所设置和更改
- 享元工厂类(Flyweight Factory): 替外部客户端管理共享资源的类
- 抽象享元类(Flyweight): 享元模式的核心,由享元工厂进行创建和管理,里面包含了内部状态,但不包含外部状态
- 共享的具体享元类(Concrete Flyweight): 实现了Flyweight声明的接口并访问和存储了内部状态

![](images/FlyweightUML.png)

#### 享元模式的工作步骤
- 拆分类的成员变量,将成员变量拆分成以下两种: 
    - 不变的、可能在对象之间重复使用的
    - 变化的、随着应用场景而改动的
- 将不变的,可重复的成员变量的属性设置为不可修改,并在构造函数中赋初始值
- 创建享元类,并将共享的成员变量集成到享元类
- 创建享元工厂类来管理共享的资源池,客户端与享元对象的交互借助享元工厂来实现
- 优化共享资源池的代码实现,这可能涉及到事件驱动、回调函数或者策略模式的应用

#### 享元模式的应用场景
- 图形或图像处理:
    - 在大型游戏或图形编辑器开发中, 同一个形状（如矩形）或颜色等状态会重复出现很多次, 基于享元模式可以降低内存开销
- 数据库处理优化:
    - 数据库被频繁地连接和请求时, 享元模式可以管理这些连接并复用它们, 提高处理的性能
- UI组件开发:
    - 在用户界面中, 当创建多个界面窗口时, 像按钮、图标等小部件会在创建界面窗口时有大量重复, 使用享元模式可以减少界面之间重复组件的数量, 提高性能

**享元模式的优缺点**
- 享元模式的优点:
    - 增加了系统资源的可重用性, 节省了系统资源
    - 基于共享的结构, 降低了内存消耗
    - 系统可扩展性强, 新增对象时可直接复用共享资源
    - 降低了对象内部的结构复杂性
- 享元模式的缺点:
    - 使代码结构更加复杂
    - 当需要被共享的资源量级很小时, 该模式的性能提升并不显著
    - 将共享变量放在构造函数中进行赋值, 额外增加了初始化的时间
    - 引入了"共享"这种结构, 会导致潜在的线程安全问题
    - 编写代码需要考虑保证状态的同步和一致性问题, 否则会导致bug的产生

### Composite 组合模式
- 真实世界中像企业组织、文档、图形软件界面等案例, 它们在结构上都是分层次的;
- 将系统分层次的方式使得统一管理和添加不同子模块变得容易, 在软件开发中, 组合模式的设计思想和它们类似
- 组合模式是一种结构型设计模式, 该模式将对象组合成**树状结构**, 以便于分层和统一管理
- 组合模式用于为复杂的分层的系统结构定义基本的蓝图, 并对外**提供统一的接口**, 简化了系统组件的使用方法

#### 组合模式的结构
- 组件类(Component): 声明了统一的抽象接口; 它定义了Leaf类和Composite类的通用函数接口
- 叶子节点类(Leaf): 提供了Component类的接口实现, 组合模式中的最小单元
- 组合类(Composite): 也提供了Component类的接口实现, 其中包含多个Component对象; 它对子组件进行了封装, 使用客户端(Client)可以像操作单个组件一样使用整个组合

![](images/CompositeUML.png)

#### 组合模式的应用场景
- 平面设计软件开发: 在PS等应用程序中, 形状、线条和文本等图形元素可以组合成复杂的设计
- 文件系统: 使用组合模式来表示文件和目录, 从而形成可以统一处理和查询的分层结构
- UI框架开发: 基于组合模式, 可以让UI组件(如按钮、标签和面板等)组合成复杂的布局或界面
- 文档编辑器: 使用组合模式来实现文档的段落和文本等层次结构
- 企业软件开发: 企业软件通常对组织结构进行建模, 包括部门、团队和员工; 组合模式用于实现组织单位及其内部员工的层次结构

**组合模式的优缺点**
- 组合模式的优点:
    - 便于维护和重构, 修改单个组件的代码不会影响整个系统的功能
    - 有树形结构的先天优势, 可以很方便地统一添加、删除或修改子节点
    - 通过拆分子组件, 提高了模块间的独立性和可重用性
    - 符合"单一职责原则", 组合中的每个对象只关注自己的职责, 不需要考虑整个组合中的功能配合
- 组合模式的缺点:
    - 性能开销大, 该模式涉及了对象的动态创建和管理, 频繁操作可能会引起性能问题
    - 增加了代码的复杂度, 当组合的层次过深的时候, 代码的结构会很复杂
    - 类型安全问题, 当管理多个组件对象时, 可能需要额外的类型转换编码

### Template Method 模板方法模式

> 模板方法模式是一种行为型设计模式, 它先定义了一个算法的大致框架, 然后将算法的具体实现步骤分解到多个子类中; 模板方法模式为算法设计了一个抽象的模板, 算法的具体代码细节由子类来实现, 从而使算法在整体上结构稳定, 但是又能被灵活修改和扩展.

![](images/TemplateMethodUML.png)

#### 模板方法模式的结构
- 模板方法模式主要包含以下组件:
    - 抽象类(AbstractClass):
        - 定了算法的大致框架, 里面包含了一个模板方法(templateMethod)和多个基本操作方法(execute1, execute2)
        - 模板方法定义了算法的实现步骤, 而算法的实现步骤由这些基本操作组成
        - 抽象类只定义了模板方法和基本操作流程, 不提供具体的代码实现
    - 具体类(ConcreteClass):
        - 是抽象类的具体实现, 里面实现了抽象类定义的基本操作方法(execute1, execute2)
        - 不同的具体类对基本操作方法的实现细节可能有差异
- 组件之间的工作步骤如下:
    - 在抽象类中定义一个模板方法(templateMethod), 将模板方法作为算法的大致框架
    - 在抽象类中声明若干个基本操作方法(execute1, execute2), 将这些方法在模板方法中按特定顺序调用, 作为算法的执行流程
    - 在不同的具体类中, 按照业务分别用代码实现基本操作方法

#### 模板方法模式的应用场景
- 软件框架开发: 开发复杂的框架时先定义好基础流程, 然后在子类中分别实现具体细节
- 编译器开发: 在编译器中先定义基本的步骤如词法分析、语法分析等, 然后在子类中实现具体的解析步骤
- 驱动程序开发: 将程序的初始化、数据读写、通信等基础操作抽象为模板方法, 然后根据不同的设备参数实现具体操作

#### 模板方法模式的优缺点
- 模板方法模式的优点:
    - 使代码更加简洁, 具体细节交给子类实现, 避免了重复代码
    - 模板方法定义以后, 后面只需要重点维护子类的代码实现, 系统可扩展性和灵活性很强
    - 系统稳定性强, 无论后续如何修改子类, 算法的基本流程不变
- 模板方法模式的缺点:
    - 子类太多容易导致继承的过度滥用
    - 系统结构复杂, 增加了代码维护难度
    - 如果有些基本操作没有提供默认的行为, 可能导致功能出错



### Reference

- [设计模式(全23种)](https://subingwen.cn/design-patterns/)
- [Design Patterns](https://refactoringguru.cn/design-patterns/cpp)
- [图说设计模式](https://design-patterns.readthedocs.io/zh-cn/latest/index.html#)
