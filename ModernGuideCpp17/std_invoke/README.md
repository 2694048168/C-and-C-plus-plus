### 现代C++ 调用函数优雅：std::invoke 

> "可调用对象"(Callable Object)是一个宽泛的概念,它涵盖了普通函数、函数指针、成员函数指针、Lambda 表达式、函数对象(Functor)等多种实体; 然而在 C++17 之前, 调用这些不同类型的可调用对象却缺乏一种统一的语法; 这种语法上的不一致性, 尤其在泛型编程和模板元编程中, 带来了诸多挑战. C++17 标准引入了 std::invoke, 设计哲学非常清晰：提供一个统一的、规范化的调用接口, 屏蔽底层不同可调用对象之间的语法差异; std::invoke本质上是一个函数模板, 它将调用操作"包装"成一个标准的函数调用形式 std::invoke(f, args...), 从而让泛型代码能够以一种简单、一致的方式与任何可调用对象进行交互.

#### 核心机制：std::invoke如何统一调用

> std::invoke(f, t1, t2, ..., tN) 的工作原理可以概括为：它会根据 f的类型和第一个参数 t1的类型, 智能地将其转换为对应类型的合法调用; 其内部实现(概念上)依赖于一系列精心设计的规则, 以匹配 C++ 中所有合法的调用形式.

- 场景一：泛型回调与事件系统
- 场景二：模板元编程与高阶函数
