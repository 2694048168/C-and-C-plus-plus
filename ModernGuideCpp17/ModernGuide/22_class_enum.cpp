/**
 * @file 22_class_enum.cpp
 * @author Wei Li (weili_yzzcq@163.com)
 * @brief 
 * @version 0.1
 * @date 2024-09-04
 * 
 * @copyright Copyright (c) 2024
 * 
 */

/** 1. 枚举的使用
 * 枚举类型是C及C++中一个基本的内置类型,不过也是一个有点"奇怪"的类型.
 * 从枚举的本意上来讲,就是要定义一个类别,并穷举同一类别下的个体以供代码中使用.
 * 由于枚举来源于C,所以出于设计上的简单的目的,枚举值常常是对应到整型数值的一些名字.
 * *在枚举类型中的枚举值编译器会默认从0开始赋值,而后依次向下递增.
 * 
 * 2. 枚举的缺陷
 * C/C++的enum有个很"奇怪"的设定,就是具名(有名字)的enum类型的名字,
 * *以及 enum 的成员的名字都是全局可见的. 这与 C++中具名的 namespace、class/struct 及 union 
 * 必须通过名字::成员名的方式访问相比是格格不入的,编码过程中一不小心程序员就容易遇到问题.
 * *由于C中枚举被设计为常量数值的"别名"的本性,所以枚举的成员总是可以被隐式地转换为整型;
 * 
 * 3. 强类型枚举
 * C++11标准引入了一种新的枚举类型,即枚举类,又称强类型枚举(strong-typed enum),
 * ?声明强类型枚举非常简单,只需要在 enum 后加上关键字 class;
 * *----强作用域, 强类型枚举成员的名称不会被输出到其父作用域空间;
 *    ---强类型枚举只能是有名枚举,如果是匿名枚举会导致枚举值无法使用(因为没有作用域名称);
 * *----转换限制, 强类型枚举成员的值不可以与整型隐式地相互转换;
 * *----可以指定底层类型, 强类型枚举默认的底层类型为 int, 但也可以显式地指定底层类型,
 *    ---具体方法为在枚举名称后面加上∶type, 其中 type 可以是除 wchar_t 以外的任何整型;
 * 
 * 
 * 
 */

#include <iostream>

enum class China
{
    Shanghai,
    DongJin,
    Beijing,
    Nanjing,
};

enum class Japan : char
{
    DongJin,
    DaBan,
    HenBin,
    FuDao
};

// -----------------------------------
int main(int argc, const char **argv)
{
    // 强类型枚举属于强作用于类型，不能直接使用，枚举值前必须加枚举类型
    // 强类型枚举不会进行隐式类型转换，因此枚举值不能直接给int行变量赋值
    // （虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。
    // int m = Shanghai; // !error

    // 语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换
    // int n = China::Shanghai; // !error

    // 语法正确，强类型枚举值在和整数比较之前做了强制类型转换
    if ((int)China::Beijing >= 2)
    {
        std::cout << "ok!" << std::endl;
    }

    // 强类型枚举底层类型值默认为int，因此占用的内存是4个字节
    std::cout << "size1: " << sizeof(China::DongJin) << std::endl;

    // 显示指定了强类型枚举值的类型为char，因此占用的内存大小为1个字节，这样节省更多的内存空间了
    std::cout << "size2: " << sizeof(Japan::DongJin) << std::endl;

    /* C++11中对原有枚举类型的这两个扩展都保留了向后兼容性,
    也方便了程序员在代码中同时操作两种枚举类型.
    在声明强类型枚举的时候,也可以使用关键字enum struct,
    实际上 enum struct 和enum class在语法上没有任何区别
    （enum class 的成员没有公有私有之分，也不会使用模板来支持泛化的声明 ） */

    return 0;
}
